// routes/product.js
const express = require('express');
const router = express.Router();
const axios = require('axios');
const { MongoClient } = require('mongodb');
const { cacheService } = require('../services/cacheService');
const { normalizeItem } = require('../utils/normalize');
const { connectMongoDB } = require('../config/mongodb');  // DB Ïó∞Í≤∞ Î≥¥Ïû•
const { saveBatchFromCrawler } = require('../services/nosql');  // Î∞∞Ïπò Ï†ÄÏû•
const websocketService = require('../services/websocketService');

// =========================
// MongoDB Ïó∞Í≤∞ Î≥¥Ïû• ÎØ∏Îì§Ïõ®Ïñ¥
// =========================
router.use(async (_req, _res, next) => {
  const db = await connectMongoDB(); // DB Ïó∞Í≤∞ Î≥¥Ïû•
  if (!db) {
    return _res.status(503).json({ error: 'MongoDB Ïó∞Í≤∞ Ïã§Ìå®' });
  }
  next();  // Îã§Ïùå ÎØ∏Îì§Ïõ®Ïñ¥Î°ú ÏßÑÌñâ
});

// =========================
// GET /api/products (Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå + ÌïÑÏöîÏãú ÌÅ¨Î°§ÎßÅ)
// =========================
router.get('/', async (req, res) => {
  try {
    const { q, query, max_links = 10 } = req.query;
    const searchTerm = (q || query || '').trim();

    console.log('üîç GET /api/products ÏöîÏ≤≠:', { searchTerm, max_links });

    if (!searchTerm) {
      return res.status(400).json({ error: 'Í≤ÄÏÉâÏñ¥Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.' });
    }

    // 1. Î®ºÏ†Ä Redis Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º ÌôïÏù∏
    console.log('üîç Redis Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º ÌôïÏù∏ Ï§ë...');
    const cachedResults = await cacheService.getSearchResults(searchTerm);
    
    if (cachedResults && cachedResults.results && cachedResults.results.products) {
      console.log(`‚úÖ Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º Î∞úÍ≤¨: ${searchTerm} - ${cachedResults.totalCount}Í∞ú ÏÉÅÌíà`);
      
      // Ï∫êÏãúÎêú Í≤∞Í≥ºÍ∞Ä Ï∂©Î∂ÑÌïòÎ©¥ Î∞îÎ°ú Î∞òÌôò
      if (cachedResults.totalCount >= parseInt(max_links)) {
        const slicedProducts = cachedResults.results.products.slice(0, parseInt(max_links));
        
        return res.json({
          success: true,
          products: slicedProducts,
          total: slicedProducts.length,
          cached: true,
          cachedAt: cachedResults.cachedAt,
          source: 'redis_cache'
        });
      } else {
        console.log(`‚ö†Ô∏è Ï∫êÏãúÎêú Í≤∞Í≥º Î∂ÄÏ°±: ${cachedResults.totalCount}Í∞ú < ${max_links}Í∞ú, DB Î∞è ÌÅ¨Î°§ÎßÅ ÌôïÏù∏`);
      }
    } else {
      console.log('üîç Ï∫êÏãúÏóê Í≤ÄÏÉâ Í≤∞Í≥º ÏóÜÏùå, DB ÌôïÏù∏');
    }

    const db = await connectMongoDB();

    // 2. MongoDBÏóêÏÑú Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
    console.log('üìã MongoDBÏóêÏÑú Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë...');
    const queryObj = { title: { $regex: new RegExp(escapeRegex(searchTerm), 'i') } };
    const existingProducts = await db.collection('products')
      .find(queryObj)
      .sort({ last_seen_at: -1 })
      .limit(parseInt(max_links))
      .toArray();

    console.log(`üìã Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞: ${existingProducts.length}Í∞ú ÏÉÅÌíà Î∞úÍ≤¨`);

    // 2. Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Í∞Ä Ï∂©Î∂ÑÌïòÏßÄ ÏïäÏúºÎ©¥ ÌÅ¨Î°§ÎßÅ ÏàòÌñâ
    if (existingProducts.length < parseInt(max_links)) {
      console.log('üì° Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Î∂ÄÏ°±, ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤ÑÏóê ÏöîÏ≤≠...');

      try {
        // ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤ÑÏóê POST ÏöîÏ≤≠
        const crawlingServerUrl = process.env.CRAWLING_SERVER_URL || 'http://10.128.3.36:30800';
        const crawlingEndpoint = `${crawlingServerUrl}/info_list`;

        console.log(`üì° ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Ìò∏Ï∂ú: ${crawlingEndpoint}`);

        const response = await axios.post(
          crawlingEndpoint,
          { keyword: searchTerm, max_links: parseInt(max_links) },
          { 
            headers: { 'Content-Type': 'application/json' }, 
            timeout: 30000,  // 30Ï¥àÎ°ú Îã®Ï∂ï
            validateStatus: function (status) {
              return status < 600; // 504 Gateway TimeoutÎèÑ ÌóàÏö©
            }
          }
        );

        console.log('üìù ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ ÏùëÎãµ ÏÉÅÌÉú:', response.status);

        // 504 Gateway Timeout Ï≤òÎ¶¨
        if (response.status === 504) {
          console.warn('‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Gateway Timeout (504) - Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©');
          // Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ÎßåÏúºÎ°ú ÏùëÎãµ Í≥ÑÏÜç ÏßÑÌñâ
        } else if (response.data && response.data.info_list) {
          const newProducts = Array.isArray(response.data.info_list) ? response.data.info_list : [];
          console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ${newProducts.length}Í∞ú ÏÉÅÌíà ÏàòÏßë`);

          // 3. ÏÉàÎ°ú ÏàòÏßëÎêú ÏÉÅÌíàÏùÑ MongoDBÏóê Ï†ÄÏû•
          const normalized = newProducts.map(normalizeItem).filter(v => v.product_code && v.url);

          console.log(`üíæ ${normalized.length}Í∞ú ÏÉÅÌíàÏùÑ MongoDBÏóê Ï†ÄÏû• Ï§ë...`);

          for (const item of normalized) {
            try {
              await db.collection('products').updateOne(
                { product_code: item.product_code },
                {
                  $set: {
                    title: item.title,
                    url: item.url,
                    image_url: item.image_url,
                    final_price: item.final_price,
                    origin_price: item.origin_price,
                    review_count: item.review_count,
                    review_rating: item.review_rating,
                    last_seen_at: new Date(),
                    updated_at: new Date(),
                  },
                },
                { upsert: true }
              );
              console.log(`‚úÖ ÏÉÅÌíà Ï†ÄÏû• ÏôÑÎ£å: ${item.title}`);
            } catch (dbError) {
              console.error('‚ùå DB Ï†ÄÏû• Ïò§Î•ò:', dbError);
            }
          }

          // 4. Ï†ÄÏû•Îêú ÏÉÅÌíàÎì§ÏùÑ Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ÏôÄ Ìï©Ï≥êÏÑú Î∞òÌôò
          const allProducts = [...existingProducts, ...normalized];
          const formattedProducts = allProducts.map(product => ({
            id: product._id?.toString() || product.product_code,
            name: product.title || product.product_code,
            url: product.url,
            imageUrl: product.image_url,
            currentPrice: product.final_price ? parseFloat(product.final_price.replace(/[^0-9.]/g, '')) : null,
            originalPrice: product.origin_price ? parseFloat(product.origin_price.replace(/[^0-9.]/g, '')) : null,
            averageRating: product.review_rating ? parseFloat(product.review_rating) : null,
            totalReviews: product.review_count ? parseInt(product.review_count.replace(/[^0-9]/g, '')) : 0,
            productCode: product.product_code || null
          }));

          console.log(`üéâ GET ÏöîÏ≤≠ ÏôÑÎ£å: Ï¥ù ${formattedProducts.length}Í∞ú ÏÉÅÌíà (Í∏∞Ï°¥: ${existingProducts.length}, ÏÉàÎ°ú ÏàòÏßë: ${normalized.length})`);

          // 5. Í≤ÄÏÉâ Í≤∞Í≥ºÎ•º Redis Ï∫êÏãúÏóê Ï†ÄÏû•
          console.log(`üíæ Redis Ï∫êÏãúÏóê GET Í≤∞Í≥º Ï†ÄÏû• Ï§ë: ${searchTerm}`);
          try {
            const searchResults = {
              query: searchTerm,
              products: allProducts, // ÏõêÎ≥∏ Îç∞Ïù¥ÌÑ∞ Ï†ÄÏû•
              total: allProducts.length,
              timestamp: new Date().toISOString()
            };
            
            await cacheService.setSearchResults(searchTerm, searchResults);
            console.log(`‚úÖ Redis Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å: ${searchTerm} - ${allProducts.length}Í∞ú ÏÉÅÌíà`);
            
            // Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥ÏóêÎèÑ Ï∂îÍ∞Ä
            await cacheService.addPopularSearch(searchTerm);
          } catch (cacheError) {
            console.warn('‚ö†Ô∏è Redis Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®:', cacheError);
          }

          res.json({
            success: true,
            products: formattedProducts,
            message: `"${searchTerm}"Ïóê ÎåÄÌïú ${formattedProducts.length}Í∞ú ÏÉÅÌíàÏùÑ Ï∞æÏïòÏäµÎãàÎã§. (Í∏∞Ï°¥: ${existingProducts.length}, ÏÉàÎ°ú ÏàòÏßë: ${normalized.length})`,
            fromCache: false
          });
          return;
        }
      } catch (crawlError) {
        console.error('‚ùå ÌÅ¨Î°§ÎßÅ Ïã§Ìå®:', crawlError);
        console.log('‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ Ïã§Ìå®, Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Îßå Î∞òÌôò');
      }
    }

    // 5. ÌÅ¨Î°§ÎßÅÏù¥ Ïã§Ìå®ÌñàÍ±∞ÎÇò Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞Îßå ÏÇ¨Ïö©ÌïòÎäî Í≤ΩÏö∞
    const formattedProducts = existingProducts.map(product => ({
      id: product._id?.toString() || product.product_code,
      name: product.title || product.product_code,
      url: product.url,
      imageUrl: product.image_url,
      currentPrice: product.final_price ? parseFloat(product.final_price.replace(/[^0-9.]/g, '')) : null,
      originalPrice: product.origin_price ? parseFloat(product.origin_price.replace(/[^0-9.]/g, '')) : null,
      averageRating: product.review_rating ? parseFloat(product.review_rating) : null,
      totalReviews: product.review_count ? parseInt(product.review_count.replace(/[^0-9]/g, '')) : 0,
      productCode: product.product_code || null
    }));

    console.log(`‚úÖ GET ÏöîÏ≤≠ ÏôÑÎ£å: Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ${formattedProducts.length}Í∞ú ÏÉÅÌíà Î∞òÌôò`);

    res.json({
      success: true,
      products: formattedProducts,
      message: `"${searchTerm}"Ïóê ÎåÄÌïú ${formattedProducts.length}Í∞ú ÏÉÅÌíàÏùÑ Ï∞æÏïòÏäµÎãàÎã§.`,
      fromCache: true
    });

  } catch (error) {
    console.error('‚ùå GET /api/products ÏóêÎü¨:', error);
    res.status(500).json({ error: 'ÏÉÅÌíà Ï°∞Ìöå Ï§ë Ïò§Î•òÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.' });
  }
});

// =========================
// GET /api/products (ÏÉÅÌíà Í≤ÄÏÉâ + ÌéòÏù¥ÏßÄÎÑ§Ïù¥ÏÖò)
// =========================
router.get('/list', async (req, res) => {
  try {
    let { q, query, page = 1, page_size = 20 } = req.query;
    if (q === 'undefined') q = '';
    if (query === 'undefined') query = '';

    const searchTerm = (q || query || '').trim();
    const pageNum = Math.max(1, Number(page) || 1);
    const pageSize = Math.min(100, Math.max(1, Number(page_size) || 20));
    const rawKey = `${searchTerm}|${pageNum}|${pageSize}`;

    // Ï∫êÏãú Ï°∞Ìöå
    if (searchTerm) {
      try {
        const cached = await cacheService.getSearchResults(rawKey);
        if (cached) {
          console.log('‚úÖ Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º Î∞òÌôò:', searchTerm);
          return res.json({ ...cached.results, fromCache: true });
        }
      } catch (e) {
        console.warn('[cache] getSearchResults Ïã§Ìå®, Ï∫êÏãú Î¨¥Ïãú:', e?.message || e);
      }
    }

    const db = await connectMongoDB();  // DB Ïó∞Í≤∞ Î≥¥Ïû•
    const queryObj = searchTerm
      ? { title: { $regex: new RegExp(escapeRegex(searchTerm), 'i') } }
      : {};

    const cursor = db.collection('products').find(queryObj).sort({ _id: -1 }).skip((pageNum - 1) * pageSize).limit(pageSize);
    const [docs, total] = await Promise.all([cursor.toArray(), db.collection('products').countDocuments(queryObj)]);

    const responseData = {
      products: docs,
      total,
      searchTerm: searchTerm || null,
      page: pageNum,
      page_size: pageSize,
      fromCache: false,
    };

    // Ï∫êÏãú Ï†ÄÏû• & Ïù∏Í∏∞/ÌûàÏä§ÌÜ†Î¶¨
    if (searchTerm && docs.length > 0) {
      try {
        await cacheService.setSearchResults(rawKey, responseData);
      } catch (e) {
        console.warn('[cache] setSearchResults Ïã§Ìå®:', e?.message || e);
      }
      try {
        await cacheService.addPopularSearch(searchTerm);
      } catch (e) {
        console.warn('[cache] addPopularSearch Ïã§Ìå®:', e?.message || e);
      }
      if (req.session?.userId) {
        try {
          await cacheService.addUserSearchHistory(req.session.userId, searchTerm);
        } catch (e) {
          console.warn('[cache] addUserSearchHistory Ïã§Ìå®:', e?.message || e);
        }
      }
    }

    return res.json(responseData);
  } catch (error) {
    console.error('ÏÉÅÌíà Ï°∞Ìöå ÏóêÎü¨:', error);
    return res.status(500).json({ error: 'ÏÉÅÌíà Ï°∞Ìöå Ïã§Ìå®' });
  }
});

// ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏÉÅÌÉú Ï†ÄÏû•ÏÜå (Î©îÎ™®Î¶¨ Í∏∞Î∞ò)
const crawlJobs = new Map();

// =========================
// POST /api/products (ÎπÑÎèôÍ∏∞ ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏãúÏûë)
// =========================
router.post('/', async (req, res) => {
  console.log('üöÄ POST /api/products ÏöîÏ≤≠ ÏàòÏã†');
  console.log('üìù ÏöîÏ≤≠ Î≥∏Î¨∏:', req.body);

  try {
    const keyword = (req.body.keyword || '').trim();
    const page = Number(req.body.page || 1);
    const per_page = Number(req.body.per_page || 10);
    const max_links = req.body.max_links ? Number(req.body.max_links) : (page * per_page);
    const forceCrawl = Boolean(req.body.force_crawl || false);

    console.log(`üìã ÏöîÏ≤≠ ÌååÎùºÎØ∏ÌÑ∞: keyword="${keyword}", page=${page}, per_page=${per_page}, max_links=${max_links}, force_crawl=${forceCrawl}`);

    if (!keyword) {
      console.log('‚ùå Í≤ÄÏÉâÏñ¥Í∞Ä ÏóÜÏùå');
      return res.status(400).json({ error: 'Í≤ÄÏÉâÏñ¥Í∞Ä ÌïÑÏöîÌï©ÎãàÎã§.' });
    }

    // Í∞ïÏ†ú ÌÅ¨Î°§ÎßÅÏù¥ ÏïÑÎãå Í≤ΩÏö∞ÏóêÎßå Ï∫êÏãúÏôÄ DB ÌôïÏù∏
    if (!forceCrawl) {
      // 1. Î®ºÏ†Ä Redis Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º ÌôïÏù∏
      console.log('üîç Redis Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º ÌôïÏù∏ Ï§ë...');
      const cachedResults = await cacheService.getSearchResults(keyword);
      
      if (cachedResults && cachedResults.results && cachedResults.results.products) {
        console.log(`‚úÖ Ï∫êÏãúÏóêÏÑú Í≤ÄÏÉâ Í≤∞Í≥º Î∞úÍ≤¨: ${keyword} - ${cachedResults.totalCount}Í∞ú ÏÉÅÌíà`);
        
        // ÌéòÏù¥ÏßÄ Í∏∞Î∞ò Ï∫êÏãú Í≤∞Í≥º Î∞òÌôò
        const startIndex = (page - 1) * per_page;
        const endIndex = startIndex + per_page;
        const pageProducts = cachedResults.results.products.slice(startIndex, endIndex);
        
        if (pageProducts.length > 0) {
          const jobId = `cached_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
          
          return res.json({
            success: true,
            jobId,
            message: `Ï∫êÏãúÎêú Í≤∞Í≥º ÌéòÏù¥ÏßÄ ${page}: ${pageProducts.length}Í∞ú ÏÉÅÌíà`,
            status: 'completed',
            products: pageProducts,
            productCount: pageProducts.length,
            cached: true,
            cachedAt: cachedResults.cachedAt,
            pagination: {
              page,
              per_page,
              total: cachedResults.totalCount,
              hasMore: endIndex < cachedResults.totalCount
            }
          });
        } else {
          console.log(`‚ö†Ô∏è Ï∫êÏãúÏóêÏÑú ÌéòÏù¥ÏßÄ ${page} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: Ï¥ù ${cachedResults.totalCount}Í∞ú, ÏöîÏ≤≠ Î≤îÏúÑ: ${startIndex}-${endIndex}`);
        }
      } else {
        console.log('üîç Ï∫êÏãúÏóê Í≤ÄÏÉâ Í≤∞Í≥º ÏóÜÏùå, DB ÌôïÏù∏');
      }

      // 2. MongoDBÏóêÏÑú Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ ÌôïÏù∏
      console.log('üìã MongoDBÏóêÏÑú Í∏∞Ï°¥ Îç∞Ïù¥ÌÑ∞ Ï°∞Ìöå Ï§ë...');
      const db = await connectMongoDB();
      const queryObj = { title: { $regex: new RegExp(escapeRegex(keyword), 'i') } };
      
      // ÌéòÏù¥ÏßÄ Í∏∞Î∞òÏúºÎ°ú MongoDB Ï°∞Ìöå
      const totalProducts = await db.collection('products').countDocuments(queryObj);
      const startIndex = (page - 1) * per_page;
      
      const pageProducts = await db.collection('products')
        .find(queryObj)
        .sort({ last_seen_at: -1 })
        .skip(startIndex)
        .limit(per_page)
        .toArray();

      console.log(`üìã MongoDB Ï¥ù ${totalProducts}Í∞ú ÏÉÅÌíà Ï§ë ÌéòÏù¥ÏßÄ ${page}ÏóêÏÑú ${pageProducts.length}Í∞ú Î∞úÍ≤¨`);

      // 3. MongoDBÏóêÏÑú Ìï¥Îãπ ÌéòÏù¥ÏßÄ Îç∞Ïù¥ÌÑ∞Í∞Ä ÏûàÏúºÎ©¥ Î∞îÎ°ú Î∞òÌôò
      if (pageProducts.length > 0) {
        console.log(`‚úÖ MongoDB ÌéòÏù¥ÏßÄ ${page} Îç∞Ïù¥ÌÑ∞ ÏûàÏùå: ${pageProducts.length}Í∞ú ÏÉÅÌíà`);
        
        const jobId = `db_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
        const normalized = pageProducts.map(normalizeItem);
        
        // Ï≤´ ÌéòÏù¥ÏßÄÏù¥Í±∞ÎÇò Ï†ÑÏ≤¥ Îç∞Ïù¥ÌÑ∞Í∞Ä Ï∂©Î∂ÑÌï† ÎïåÎßå Ï∫êÏãúÏóê Ï†ÄÏû•
        if (page === 1 && totalProducts >= 10) {
          console.log(`üíæ MongoDB Í≤∞Í≥ºÎ•º Redis Ï∫êÏãúÏóê Ï†ÄÏû•: ${keyword}`);
          try {
            const allProducts = await db.collection('products')
              .find(queryObj)
              .sort({ last_seen_at: -1 })
              .limit(Math.max(50, totalProducts)) // ÏµúÎåÄ 50Í∞úÍπåÏßÄ Ï∫êÏãú
              .toArray();
            
            const searchResults = {
              query: keyword,
              products: allProducts.map(normalizeItem),
              total: totalProducts,
              timestamp: new Date().toISOString()
            };
            
            await cacheService.setSearchResults(keyword, searchResults);
            await cacheService.addPopularSearch(keyword);
            console.log(`‚úÖ Redis Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å: ${keyword} (${allProducts.length}Í∞ú ÏÉÅÌíà)`);
          } catch (cacheError) {
            console.warn('‚ö†Ô∏è Redis Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®:', cacheError);
          }
        }
        
        return res.json({
          success: true,
          jobId,
          message: `DB ÌéòÏù¥ÏßÄ ${page} Í≤∞Í≥º: ${normalized.length}Í∞ú ÏÉÅÌíà`,
          status: 'completed',
          products: normalized,
          productCount: normalized.length,
          cached: false,
          fromDatabase: true,
          pagination: {
            page,
            per_page,
            total: totalProducts,
            hasMore: startIndex + per_page < totalProducts
          },
          timestamp: new Date().toISOString()
        });
      } else {
        console.log(`‚ö†Ô∏è MongoDB ÌéòÏù¥ÏßÄ ${page} Îç∞Ïù¥ÌÑ∞ ÏóÜÏùå: Ï¥ù ${totalProducts}Í∞ú, ÌÅ¨Î°§ÎßÅ ÏàòÌñâ`);
      }
    } else {
      console.log('üöÄ Í∞ïÏ†ú ÌÅ¨Î°§ÎßÅ ÏöîÏ≤≠ - Ï∫êÏãúÏôÄ DB Í±¥ÎÑàÎõ∞Í≥† Î∞îÎ°ú ÌÅ¨Î°§ÎßÅ ÏàòÌñâ');
    }

    // 4. Ï∫êÏãúÏôÄ DBÏóê Ï∂©Î∂ÑÌïú Îç∞Ïù¥ÌÑ∞Í∞Ä ÏóÜÏúºÎ©¥ ÌÅ¨Î°§ÎßÅ ÏàòÌñâ
    // ÏûëÏóÖ ID ÏÉùÏÑ±
    const jobId = `crawl_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;

    // ÏûëÏóÖ ÏÉÅÌÉú Ï¥àÍ∏∞Ìôî
    crawlJobs.set(jobId, {
      status: 'started',
      keyword,
      page,
      per_page,
      max_links,
      startTime: new Date(),
      products: [],
      error: null
    });

    console.log(`üîç ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏãúÏûë: ${jobId} - ${keyword} (ÌéòÏù¥ÏßÄ ${page})`);

    // WebSocketÏúºÎ°ú Ïã§ÏãúÍ∞Ñ Í≤ÄÏÉâ ÏãúÏûë ÏïåÎ¶º
    try {
      await websocketService.emitToRoom(`search:${jobId}`, 'search-started', {
        jobId,
        status: 'started',
        keyword,
        page,
        per_page,
        max_links,
        timestamp: new Date().toISOString(),
        message: `Í≤ÄÏÉâ ÏãúÏûë: "${keyword}" ÏÉÅÌíàÏùÑ Ï∞æÍ≥† ÏûàÏäµÎãàÎã§...`
      });
      console.log(`üîî WebSocket search start notification sent: ${jobId}`);
    } catch (wsError) {
      console.warn('‚ö†Ô∏è WebSocket ÏãúÏûë ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', wsError.message);
    }

    // ÎèôÍ∏∞Ï†ÅÏúºÎ°ú ÌÅ¨Î°§ÎßÅ Ïã§Ìñâ ÌõÑ Í≤∞Í≥º Î∞òÌôò
    console.log(`üì° ÌÅ¨Î°§ÎßÅ Ïã§Ìñâ ÏãúÏûë: ${jobId}`);

    // ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Ìò∏Ï∂ú - ÌéòÏù¥ÏßÄ Í∏∞Î∞ò ÌååÎùºÎØ∏ÌÑ∞ Ï∂îÍ∞Ä
    const crawlingServerUrl = process.env.CRAWLING_SERVER_URL || 'http://10.128.3.36:30800';
    const crawlingEndpoint = `${crawlingServerUrl}/info_list`;

    console.log(`üì° ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Ìò∏Ï∂ú: ${crawlingEndpoint} (ÌéòÏù¥ÏßÄ ${page}, ${per_page}Í∞úÏî©)`);

    const response = await axios.post(
      crawlingEndpoint,
      { 
        keyword, 
        max_links,
        page,           // ÌéòÏù¥ÏßÄ Î≤àÌò∏ Ï†ÑÎã¨
        per_page        // ÌéòÏù¥ÏßÄÎãπ Í∞úÏàò Ï†ÑÎã¨
      },
      { 
        headers: { 'Content-Type': 'application/json' }, 
        timeout: 30000,  // 30Ï¥àÎ°ú Îã®Ï∂ï
        validateStatus: function (status) {
          return status < 600; // 504ÎèÑ ÌóàÏö©
        }
      }
    );

    console.log(`üìù ÌÅ¨Î°§ÎßÅ ÏùëÎãµ Î∞õÏùå: ${jobId} - ÏÉÅÌÉú: ${response.status}`);

    let infoList = [];
    if (response.status === 504) {
      console.warn(`‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Gateway Timeout (504): ${jobId} - Îπà Í≤∞Í≥º Î∞òÌôò`);
      infoList = []; // Îπà Î∞∞Ïó¥Î°ú Ï≤òÎ¶¨
    } else if (response.data && response.data.info_list) {
      infoList = Array.isArray(response.data.info_list) ? response.data.info_list : [];
    } else if (response.data && Array.isArray(response.data)) {
      infoList = response.data;
    }

    console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ${jobId} - ${infoList.length}Í∞ú ÏÉÅÌíà`);

    // MongoDB Ï†ÄÏû•
    const db = await connectMongoDB();
    const normalized = infoList.map(normalizeItem).filter(v => v.product_code && v.url);

    console.log(`üíæ MongoDB Ï†ÄÏû• ÏãúÏûë: ${jobId} - ${normalized.length}Í∞ú ÏÉÅÌíà`);

    for (const item of normalized) {
      try {
        await db.collection('products').updateOne(
          { product_code: item.product_code },
          {
            $set: {
              title: item.title,
              url: item.url,
              image_url: item.image_url,
              final_price: item.final_price,
              origin_price: item.origin_price,
              review_count: item.review_count,
              review_rating: item.review_rating,
              last_seen_at: new Date(),
              updated_at: new Date(),
            },
          },
          { upsert: true }
        );
      } catch (dbError) {
        console.error('‚ùå DB Ï†ÄÏû• Ïò§Î•ò:', dbError);
      }
    }

    console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏôÑÎ£å: ${jobId} - ${normalized.length}Í∞ú ÏÉÅÌíà Ï†ÄÏû•Îê®`);

    // 3. ÌÅ¨Î°§ÎßÅ Í≤∞Í≥ºÎ•º Redis Ï∫êÏãúÏóê Ï†ÄÏû•
    console.log(`üíæ Redis Ï∫êÏãúÏóê Í≤ÄÏÉâ Í≤∞Í≥º Ï†ÄÏû• Ï§ë: ${keyword}`);
    try {
      const searchResults = {
        query: keyword,
        products: normalized,
        total: normalized.length,
        timestamp: new Date().toISOString()
      };
      
      await cacheService.setSearchResults(keyword, searchResults);
      console.log(`‚úÖ Redis Ï∫êÏãú Ï†ÄÏû• ÏôÑÎ£å: ${keyword} - ${normalized.length}Í∞ú ÏÉÅÌíà`);
      
      // Ïù∏Í∏∞ Í≤ÄÏÉâÏñ¥ÏóêÎèÑ Ï∂îÍ∞Ä
      await cacheService.addPopularSearch(keyword);
    } catch (cacheError) {
      console.warn('‚ö†Ô∏è Redis Ï∫êÏãú Ï†ÄÏû• Ïã§Ìå®:', cacheError);
      // Ï∫êÏãú Ïã§Ìå®Îäî Î¨¥ÏãúÌïòÍ≥† Í≥ÑÏÜç ÏßÑÌñâ
    }

    // WebSocketÏúºÎ°ú Ïã§ÏãúÍ∞Ñ Í≤ÄÏÉâ Í≤∞Í≥º ÏïåÎ¶º
    try {
      await websocketService.emitToRoom(`search:${jobId}`, 'search-completed', {
        jobId,
        status: 'completed',
        keyword,
        products: normalized,
        productCount: normalized.length,
        cached: false,
        fromCrawling: true,
        forceCrawl: forceCrawl,
        page,
        per_page,
        timestamp: new Date().toISOString(),
        message: `Í≤ÄÏÉâ ÏôÑÎ£å: "${keyword}"Ïóê ÎåÄÌïú ${normalized.length}Í∞ú ÏÉÅÌíàÏùÑ Ï∞æÏïòÏäµÎãàÎã§.`
      });
      console.log(`üîî WebSocket search notification sent: ${jobId} - ${normalized.length} products`);
    } catch (wsError) {
      console.warn('‚ö†Ô∏è WebSocket ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', wsError.message);
    }

    // Ï¶âÏãú Í≤∞Í≥º Î∞òÌôò - ÌéòÏù¥ÏßÄ Ï†ïÎ≥¥ Ìè¨Ìï®
    res.json({
      success: true,
      jobId,
      message: forceCrawl 
        ? `ÌéòÏù¥ÏßÄ ${page} Ï∂îÍ∞Ä ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ${normalized.length}Í∞ú ÏÉÅÌíà Î∞úÍ≤¨`
        : `ÌéòÏù¥ÏßÄ ${page} ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ${normalized.length}Í∞ú ÏÉÅÌíà Ï†ÄÏû•Îê®`,
      status: 'completed',
      products: normalized,
      productCount: normalized.length,
      cached: false,
      fromCrawling: true,
      forceCrawl: forceCrawl,
      pagination: {
        page,
        per_page,
        total: normalized.length, // ÌÅ¨Î°§ÎßÅ Í≤∞Í≥ºÎäî ÌòÑÏû¨ ÌéòÏù¥ÏßÄÎßå Ïïå Ïàò ÏûàÏùå
        hasMore: normalized.length === per_page // ÏöîÏ≤≠Ìïú ÎßåÌÅº Í≤∞Í≥ºÍ∞Ä ÏûàÏúºÎ©¥ Îçî ÏûàÏùÑ Ïàò ÏûàÏùå
      },
      timestamp: new Date().toISOString()
    });

  } catch (e) {
    console.error('‚ùå POST ÌÅ¨Î°§ÎßÅ ÏãúÏûë Ïò§Î•ò:', e);
    
    // WebSocketÏúºÎ°ú Ïã§ÏãúÍ∞Ñ Í≤ÄÏÉâ Ïò§Î•ò ÏïåÎ¶º
    const errorJobId = `error_${Date.now()}`;
    
    try {
      await websocketService.emitToRoom(`search:${errorJobId}`, 'search-error', {
        jobId: errorJobId,
        status: 'error',
        keyword,
        error: e.message,
        timestamp: new Date().toISOString(),
        message: `Í≤ÄÏÉâ Ïò§Î•ò: "${keyword}" Í≤ÄÏÉâ Ï§ë Î¨∏Ï†úÍ∞Ä Î∞úÏÉùÌñàÏäµÎãàÎã§.`
      });
      console.log(`üîî WebSocket search error notification sent: ${errorJobId}`);
    } catch (wsError) {
      console.warn('‚ö†Ô∏è WebSocket Ïò§Î•ò ÏïåÎ¶º Ï†ÑÏÜ° Ïã§Ìå®:', wsError.message);
    }

    // 504 Gateway TimeoutÏù¥ÎÇò ÎÑ§Ìä∏ÏõåÌÅ¨ Ïò§Î•òÏùò Í≤ΩÏö∞ Îçî Í¥ÄÎåÄÌïòÍ≤å Ï≤òÎ¶¨
    if (e.response && e.response.status === 504) {
      console.warn('‚ö†Ô∏è ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Gateway Timeout - Îπà Í≤∞Í≥ºÎ°ú ÏùëÎãµ');
      return res.json({
        success: true,
        jobId: `timeout_${Date.now()}`,
        message: 'ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ ÏùëÎãµ ÏãúÍ∞Ñ Ï¥àÍ≥º - ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî',
        status: 'timeout',
        products: [],
        productCount: 0,
        cached: false,
        fromCrawling: false,
        error: 'Gateway Timeout'
      });
    }
    
    if (e.code === 'ECONNRESET' || e.code === 'ETIMEDOUT' || e.code === 'ECONNREFUSED') {
      console.warn(`‚ö†Ô∏è ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ Î¨∏Ï†ú: ${e.code} - Îπà Í≤∞Í≥ºÎ°ú ÏùëÎãµ`);
      return res.json({
        success: true,
        jobId: `network_error_${Date.now()}`,
        message: 'ÎÑ§Ìä∏ÏõåÌÅ¨ Ïó∞Í≤∞ Î¨∏Ï†ú - ÎÇòÏ§ëÏóê Îã§Ïãú ÏãúÎèÑÌï¥Ï£ºÏÑ∏Ïöî',
        status: 'network_error',
        products: [],
        productCount: 0,
        cached: false,
        fromCrawling: false,
        error: e.code
      });
    }
    
    res.status(500).json({ error: 'ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏãúÏûë Ïã§Ìå®', details: e.message });
  }
});

// =========================
// GET /api/products/status/:jobId (ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏÉÅÌÉú ÌôïÏù∏)
// =========================
router.get('/status/:jobId', async (req, res) => {
  try {
    const { jobId } = req.params;
    const job = crawlJobs.get(jobId);

    if (!job) {
      return res.status(404).json({ error: 'ÏûëÏóÖÏùÑ Ï∞æÏùÑ Ïàò ÏóÜÏäµÎãàÎã§.' });
    }

    console.log(`üìä ÏûëÏóÖ ÏÉÅÌÉú Ï°∞Ìöå: ${jobId} - ${job.status}`);

    res.json({
      success: true,
      jobId,
      status: job.status,
      keyword: job.keyword,
      startTime: job.startTime,
      completedTime: job.completedTime,
      products: job.products,
      productCount: job.products.length,
      error: job.error
    });

  } catch (e) {
    console.error('‚ùå ÏûëÏóÖ ÏÉÅÌÉú Ï°∞Ìöå Ïò§Î•ò:', e);
    res.status(500).json({ error: 'ÏûëÏóÖ ÏÉÅÌÉú Ï°∞Ìöå Ïã§Ìå®' });
  }
});

// =========================
// GET /api/products/debug/redis (Redis ÏÉÅÌÉú ÎîîÎ≤ÑÍπÖ)
// =========================
router.get('/debug/redis', async (req, res) => {
  try {
    console.log('üîç Redis ÏÉÅÌÉú ÎîîÎ≤ÑÍπÖ ÏöîÏ≤≠');
    
    const healthCheck = await cacheService.healthCheck();
    const cacheStats = await cacheService.getCacheStats();
    
    // ÌÖåÏä§Ìä∏ Ï∫êÏãú ÏÑ§Ï†ï/Ï°∞Ìöå
    const testKey = 'debug_test';
    const testValue = { message: 'Redis is working', timestamp: new Date().toISOString() };
    
    console.log('üß™ Redis ÌÖåÏä§Ìä∏ ÏãúÏûë...');
    const setResult = await cacheService.setSearchResults(testKey, testValue);
    const getResult = await cacheService.getSearchResults(testKey);
    
    const debugInfo = {
      health: healthCheck,
      stats: cacheStats,
      test: {
        setResult,
        getResult,
        testSuccessful: !!(setResult && getResult && getResult.results)
      },
      redis: {
        connected: cacheService.redis?.isReady() || false,
        clientStatus: cacheService.redis?.client?.status || 'unknown'
      },
      environment: {
        REDIS_HOST: process.env.REDIS_HOST || 'localhost',
        REDIS_PORT: process.env.REDIS_PORT || '6379',
        REDIS_DB: process.env.REDIS_DB || '0'
      }
    };
    
    console.log('‚úÖ Redis ÎîîÎ≤ÑÍ∑∏ Ï†ïÎ≥¥:', JSON.stringify(debugInfo, null, 2));
    
    res.json({
      success: true,
      debug: debugInfo,
      message: debugInfo.test.testSuccessful ? 'Redis Ï†ïÏÉÅ ÏûëÎèô' : 'Redis Î¨∏Ï†ú Í∞êÏßÄ'
    });
    
  } catch (error) {
    console.error('‚ùå Redis ÎîîÎ≤ÑÍπÖ Ï§ë Ïò§Î•ò:', error);
    res.status(500).json({
      success: false,
      error: error.message,
      message: 'Redis ÎîîÎ≤ÑÍπÖ Ïã§Ìå®'
    });
  }
});

// =========================
// ÎπÑÎèôÍ∏∞ ÌÅ¨Î°§ÎßÅ Ïã§Ìñâ Ìï®Ïàò
// =========================
async function performCrawling(jobId, keyword, max_links) {
  try {
    console.log(`üì° ÌÅ¨Î°§ÎßÅ Ïã§Ìñâ ÏãúÏûë: ${jobId}`);

    // ÏûëÏóÖ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    const job = crawlJobs.get(jobId);
    job.status = 'crawling';
    crawlJobs.set(jobId, job);

    // ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Ìò∏Ï∂ú
    const crawlingServerUrl = process.env.CRAWLING_SERVER_URL || 'http://10.128.3.36:30800';
    const crawlingEndpoint = `${crawlingServerUrl}/info_list`;

    console.log(`üì° ÌÅ¨Î°§ÎßÅ ÏÑúÎ≤Ñ Ìò∏Ï∂ú: ${crawlingEndpoint}`);

    const response = await axios.post(
      crawlingEndpoint,
      { keyword, max_links },
      { headers: { 'Content-Type': 'application/json' }, timeout: 30000 }
    );

    console.log(`üìù ÌÅ¨Î°§ÎßÅ ÏùëÎãµ Î∞õÏùå: ${jobId} - ÏÉÅÌÉú: ${response.status}`);

    let infoList = [];
    if (response.data && response.data.info_list) {
      infoList = Array.isArray(response.data.info_list) ? response.data.info_list : [];
    } else if (response.data && Array.isArray(response.data)) {
      infoList = response.data;
    }

    console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÏôÑÎ£å: ${jobId} - ${infoList.length}Í∞ú ÏÉÅÌíà`);

    // ÏûëÏóÖ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
    job.status = 'saving';
    crawlJobs.set(jobId, job);

    // MongoDB Ï†ÄÏû•
    const db = await connectMongoDB();
    const normalized = infoList.map(normalizeItem).filter(v => v.product_code && v.url);

    console.log(`üíæ MongoDB Ï†ÄÏû• ÏãúÏûë: ${jobId} - ${normalized.length}Í∞ú ÏÉÅÌíà`);

    for (const item of normalized) {
      try {
        await db.collection('products').updateOne(
          { product_code: item.product_code },
          {
            $set: {
              title: item.title,
              url: item.url,
              image_url: item.image_url,
              final_price: item.final_price,
              origin_price: item.origin_price,
              review_count: item.review_count,
              review_rating: item.review_rating,
              last_seen_at: new Date(),
              updated_at: new Date(),
            },
          },
          { upsert: true }
        );
      } catch (dbError) {
        console.error('‚ùå DB Ï†ÄÏû• Ïò§Î•ò:', dbError);
      }
    }

    // ÏûëÏóÖ ÏôÑÎ£å
    job.status = 'completed';
    job.products = normalized;
    job.completedTime = new Date();
    crawlJobs.set(jobId, job);

    console.log(`‚úÖ ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ ÏôÑÎ£å: ${jobId} - ${normalized.length}Í∞ú ÏÉÅÌíà Ï†ÄÏû•Îê®`);

    // 10Î∂Ñ ÌõÑ ÏûëÏóÖ Ï†ïÎ≥¥ ÏÇ≠Ï†ú (Î©îÎ™®Î¶¨ Ï†ïÎ¶¨)
    setTimeout(() => {
      crawlJobs.delete(jobId);
      console.log(`üóëÔ∏è ÏûëÏóÖ Ï†ïÎ≥¥ ÏÇ≠Ï†ú: ${jobId}`);
    }, 10 * 60 * 1000);

  } catch (error) {
    console.error(`‚ùå ÌÅ¨Î°§ÎßÅ ÏûëÏóÖ Ïã§Ìå®: ${jobId}`, error);

    // ÏûëÏóÖ Ïã§Ìå®
    const job = crawlJobs.get(jobId);
    if (job) {
      job.status = 'failed';
      job.error = error.message;
      job.completedTime = new Date();
      crawlJobs.set(jobId, job);
    }
  }
}

// escapeRegex Ìï®Ïàò Ï∂îÍ∞Ä (ÌïÑÏöîÌïú Í≤ΩÏö∞)
function escapeRegex(string) {
  return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}

module.exports = router;
